#include <stdio.h>
#include <stdlib.h>
int main()
{
	/*** 将一个小数转化为二进制表示：不断的乘2，取其中的整数部分 **/

	//例一、0.625(10) ―> 0.101(2)
	//  (1) 0.625 * 2 = 1.25, 整数部分为1，小数部分为0.25 
	//	(2) 0.25 * 2 = 0.5, 整数部分为0，小数部分为0.5 
	//	(3) 0.5 * 2 = 1, 整数部分为1，小数部分为0 
	//	所以 0.625 的二进制表示是 0.101

	//例二、0.4(10) ―> 0.0110 0110 ...(2)
	//(1) 0.4 * 2 = 0.8 整数部分为0，小数部分为0.8 
	//(2) 0.8 * 2 = 1.6 整数部分为1，小数部分为0.6 
	//(3) 0.6 * 2 = 1.2 整数部分为1，小数部分为0.2 
	//(4) 0.2 * 2 = 0.4 整数部分为0，小数部分为0.4 
	//
	//(5) 0.4 * 2 = 0.8 整数部分为0，小数部分为0.8
	//(6) 0.8 * 2 = 1.6 整数部分为1，小数部分为0.6 
	//(7) 0.6 * 2 = 1.2 整数部分为1，小数部分为0.2
	//	... ...
	//所以0.4转化为二进制，是0.0110... 这样一个无限循环小数

	/** 
		硬件单元都是有限的，只能表示有限位数的二进制位，因此存储的二进制小数就会产生两种情况
	 	一、"乘得尽"：如例一，最终小数部分为零，可以得出一个准确的结果，精度不丢失
		二、"乘不尽"：如例二，小数部分皆不为零，数据过多而 double 类型容量有限，精度丢失
	 */

	double test1 = 0.4;
	double test2 = 0.625;
	printf("test1 = %.18lf\n", test1);
	printf("test2 = %.18lf\n", test2);

	return 0;
}
